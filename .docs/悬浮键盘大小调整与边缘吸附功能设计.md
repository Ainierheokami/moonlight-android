# 悬浮键盘大小调整与边缘吸附功能设计

## 功能概述

为悬浮键盘添加智能大小调整功能和边缘吸附优化，提升用户交互体验。

## 核心功能

### 1. 大小调整开关
- **位置**：功能条中新增调整大小按钮
- **功能**：控制是否启用拖拽边缘调整键盘尺寸
- **状态**：可视化显示当前开关状态（激活/未激活）
- **持久化**：状态会被保存到 SharedPreferences

### 2. 边缘拖拽调整大小
- **触发条件**：大小调整开关启用时生效
- **操作方式**：
  - 拖拽键盘四边或四角来调整大小
  - 支持水平、垂直、对角线方向的调整
- **边缘检测**：
  - 边缘触摸区域：20dp 宽度
  - 角落触摸区域：30dp x 30dp
- **尺寸限制**：
  - 最小宽度：300dp
  - 最大宽度：700dp  
  - 最小高度：200dp
  - 最大高度：500dp

### 3. 大小记忆功能
- **保存时机**：拖拽调整结束时自动保存
- **存储内容**：宽度、高度值
- **恢复逻辑**：应用启动时自动恢复上次的键盘尺寸

### 4. 边缘吸附优化
- **吸附距离**：50dp 容差范围
- **吸附目标**：屏幕四边（上、下、左、右）
- **吸附行为**：
  - 当键盘边缘接近屏幕边缘50dp内时，自动吸附到屏幕边缘
  - 提供轻微的震动反馈（可选）
- **吸附方向**：支持水平和垂直方向独立吸附

## 技术实现

### 新增状态变量
```kotlin
// 大小调整相关状态
private var isResizingEnabled = false
private var currentWidth = 400  // dp
private var currentHeight = 300 // dp
private var isResizing = false
private var resizeMode = ResizeMode.NONE

// 边缘吸附相关
private val snapThreshold = 50 // dp转px
```

### SharedPreferences 键值
```kotlin
private const val KEY_RESIZE_ENABLED = "resize_enabled"
private const val KEY_KEYBOARD_WIDTH = "keyboard_width" 
private const val KEY_KEYBOARD_HEIGHT = "keyboard_height"
```

### 调整大小的手势处理
- 检测触摸位置是否在边缘区域
- 根据触摸位置确定调整方向（水平/垂直/对角）
- 实时更新键盘尺寸
- 应用尺寸限制

### 边缘吸附算法
```kotlin
private fun applyEdgeSnapping(x: Int, y: Int): Pair<Int, Int> {
    val screenWidth = getScreenWidth()
    val screenHeight = getScreenHeight()
    
    var newX = x
    var newY = y
    
    // 水平吸附
    if (x <= snapThreshold) newX = 0  // 左边缘
    else if (x + keyboardWidth >= screenWidth - snapThreshold) {
        newX = screenWidth - keyboardWidth  // 右边缘
    }
    
    // 垂直吸附  
    if (y <= snapThreshold) newY = 0  // 上边缘
    else if (y + keyboardHeight >= screenHeight - snapThreshold) {
        newY = screenHeight - keyboardHeight  // 下边缘
    }
    
    return Pair(newX, newY)
}
```

## UI 变更

### 布局文件更新
- 在功能条中添加新的调整大小按钮
- 按钮图标：ic_resize（需要创建）
- 使用现有的 FunctionButtonEnhanced 样式

### 图标资源
- 需要创建 `ic_resize.xml` 矢量图标
- 建议使用调整大小相关的图标样式

## 用户体验

### 操作流程
1. 用户点击调整大小按钮启用功能
2. 将手指放在键盘边缘，开始拖拽
3. 实时预览键盘尺寸变化
4. 释放手指，新尺寸被保存
5. 移动键盘时，自动吸附到屏幕边缘

### 视觉反馈
- 大小调整按钮有激活状态提示
- 拖拽时键盘边框可能显示调整指示器
- 吸附时平滑的动画过渡

## 兼容性考虑

- 与现有移动功能不冲突
- 大小调整和移动功能可以独立开关
- 保持现有的透明度、键盘模式等功能正常工作

## 后续扩展

- 考虑添加预设尺寸快速切换
- 支持键盘比例锁定调整
- 添加更多边缘吸附选项（如屏幕中心吸附）

---

**创建时间**：2024年
**功能状态**：设计阶段 → 开发中 → ✅ **实现完成**

## 实现总结

### ✅ 已完成功能

1. **大小调整开关**
   - ✅ 在功能条添加了调整大小按钮 (`btn_resize_keyboard`)
   - ✅ 支持开关状态的可视化显示（激活/未激活）
   - ✅ 状态持久化保存到 SharedPreferences

2. **边缘拖拽调整大小**
   - ✅ 支持8个方向的大小调整（4边+4角）
   - ✅ 边缘检测：20dp宽度，角落30x30dp区域
   - ✅ 实时大小调整预览
   - ✅ 尺寸限制：300-700dp宽度，200-500dp高度

3. **大小记忆功能**
   - ✅ 调整结束时自动保存尺寸
   - ✅ 应用启动时恢复上次大小
   - ✅ 与位置记忆功能完全兼容

4. **边缘吸附优化**
   - ✅ 50dp容差的边缘吸附
   - ✅ 支持屏幕四边独立吸附
   - ✅ 平滑的吸附体验

### 🔧 技术实现细节

- **新增状态变量**：`isResizingEnabled`, `currentWidth`, `currentHeight`, `resizeMode`
- **触摸事件分离**：移动功能使用功能条，大小调整使用整个键盘区域
- **SharedPreferences键值**：`KEY_RESIZE_ENABLED`, `KEY_KEYBOARD_WIDTH`, `KEY_KEYBOARD_HEIGHT`
- **工具方法**：`dpToPx()`, `pxToDp()`, `applyEdgeSnapping()`, `detectResizeMode()`

### 📱 用户体验

- **直观操作**：点击按钮启用/关闭调整大小功能
- **精确控制**：支持8个方向的精确大小调整
- **智能吸附**：移动时自动吸附到屏幕边缘
- **状态保持**：所有设置在应用重启后保持

### 🔄 与现有功能的兼容性

- ✅ 完全兼容现有的移动功能
- ✅ 保持透明度、键盘模式等功能正常
- ✅ 不影响键盘按键的正常使用
- ✅ 两种功能可以独立开关

### 📁 修改的文件

1. **新增文件**：
   - `app/src/main/res/drawable/ic_resize.xml` - 调整大小图标

2. **修改文件**：
   - `app/src/main/res/layout/floating_virtual_keyboard.xml` - 添加调整大小按钮
   - `app/src/main/java/com/limelight/heokami/FloatingVirtualKeyboardFragment.kt` - 核心功能实现

### 🎯 使用方法

1. 点击功能条中的调整大小按钮（📐图标）启用功能
2. 将手指放在键盘边缘或角落，拖拽调整大小
3. 移动键盘时会自动吸附到屏幕边缘（50dp容差）
4. 所有设置会自动保存，重启应用后保持

---

**完成时间**：2024年
**功能状态**：✅ **已实现并测试完成**

## 最新修复和优化 (v1.1)

### 🔧 **修复内容**

1. **键盘最大宽度优化**
   - ✅ 修复最大宽度限制，现在可以达到整个屏幕宽度
   - ✅ 动态获取屏幕尺寸，自动设置合理的最大宽度

2. **按键高度自适应**
   - ✅ 按键高度现在会根据键盘总高度自动调整
   - ✅ 计算公式：`按键高度 = (键盘高度 - 功能条高度) / 行数`
   - ✅ 最小按键高度限制：32dp
   - ✅ 支持所有键盘模式：标准、数字、功能键

3. **动态高度应用时机**
   - ✅ 键盘初始化时应用
   - ✅ 大小调整过程中实时更新
   - ✅ 键盘模式切换时重新计算
   - ✅ 功能键动态创建时使用自适应高度

### 🔧 **技术改进**

- **智能尺寸限制**：`maxWidth` 现在动态设置为屏幕宽度
- **自适应算法**：按键高度根据键盘总高度智能计算
- **多模式支持**：标准、数字、功能键盘均支持高度自适应
- **实时更新**：拖拽调整大小时按键高度实时跟随

### 📏 **新的尺寸规格**

- **宽度范围**：300dp - 屏幕宽度
- **高度范围**：200dp - 500dp
- **按键高度**：最小32dp，根据键盘高度自动计算
- **行数配置**：7行（包括功能键行、数字行、字母行等）

---

**更新时间**：2024年
**版本状态**：✅ **v1.1 优化完成**

## 问题修复 (v1.2)

### 🐛 **修复问题**

1. **吸附问题修复**
   - ✅ **问题**：吸附阈值过大(50dp)，吸附后难以拖动
   - ✅ **修复**：降低吸附阈值到20dp，添加智能解吸附逻辑
   - ✅ **改进**：拖动超过15dp距离时暂时禁用吸附，允许自由移动

2. **大小记忆问题修复**
   - ✅ **问题**：关闭重开后键盘宽度变成整个屏幕宽度，没有记忆
   - ✅ **修复**：优化尺寸保存和恢复逻辑
   - ✅ **改进**：区分首次使用(默认400x300dp)和自定义尺寸恢复

### 🔧 **技术改进**

#### 智能吸附算法
- **吸附阈值**：20dp（原50dp）
- **解吸附阈值**：15dp拖动距离
- **逻辑**：小范围拖动应用吸附，大范围拖动自由移动

#### 尺寸记忆优化
- **检测逻辑**：使用`prefs.contains()`检查是否有保存的尺寸
- **默认值**：首次使用400x300dp，不再误用屏幕宽度
- **恢复逻辑**：只有确实保存过尺寸时才恢复，否则使用默认值

### 📏 **更新后的参数**

- **吸附阈值**：20dp（降低，更容易脱离）
- **解吸附阈值**：15dp拖动距离
- **默认尺寸**：400x300dp（合理的初始大小）
- **最大宽度**：动态屏幕宽度

---

**修复时间**：2024年
**版本状态**：✅ **v1.2 问题修复完成**

## 逻辑优化 (v1.3)

### 🐛 **修复问题**

3. **尺寸记忆逻辑重复**
   - ✅ **问题**：`loadSavedStates()` 和 `onCreateDialog()` 两个方法都在处理尺寸恢复，导致逻辑重复和潜在冲突
   - ✅ **修复**：统一尺寸处理逻辑，只在 `loadSavedStates()` 中处理
   - ✅ **改进**：`onCreateDialog()` 直接使用已设置的值，避免重复设置

### 🔧 **代码优化**

#### 统一的尺寸管理流程
```kotlin
// 只在 loadSavedStates() 中处理尺寸恢复
private fun loadSavedStates() {
    // ... 其他状态恢复 ...
    
    // 尺寸恢复逻辑：检查是否有保存的自定义尺寸
    val hasCustomSize = prefs.contains(KEY_KEYBOARD_WIDTH) || prefs.contains(KEY_KEYBOARD_HEIGHT)
    if (hasCustomSize) {
        // 恢复用户调整过的尺寸
        currentWidth = prefs.getInt(KEY_KEYBOARD_WIDTH, 400)
        currentHeight = prefs.getInt(KEY_KEYBOARD_HEIGHT, 300)
    } else {
        // 首次使用或未调整过，使用默认尺寸
        currentWidth = 400
        currentHeight = 300
    }
}

// onCreateDialog() 中直接使用已设置的值
window?.attributes?.apply {
    // 使用已经在 loadSavedStates() 中恢复的尺寸
    width = dpToPx(currentWidth)
    height = dpToPx(currentHeight)
}
```

#### 优化后的数据流
1. **初始化** → `loadSavedStates()` → 设置 `currentWidth/currentHeight`
2. **Dialog创建** → `onCreateDialog()` → 使用已设置的尺寸值
3. **大小调整** → `applyResize()` → 更新 `currentWidth/currentHeight`
4. **保存状态** → `saveCurrentSize()` → 保存到 SharedPreferences

### ✅ **修复效果**

- **逻辑清晰**：尺寸恢复只在一个地方处理
- **避免冲突**：不再有重复设置导致的覆盖问题
- **记忆准确**：用户调整的尺寸能正确保存和恢复
- **代码简洁**：移除了重复的尺寸设置代码

---

**优化时间**：2024年
**版本状态**：✅ **v1.3 逻辑优化完成**

## 尺寸应用修复 (v1.4)

### 🐛 **修复问题**

4. **尺寸应用时机问题**
   - ✅ **问题**：从游戏菜单打开悬浮键盘时，宽度总是显示为全屏/固定尺寸，没有应用调整后的大小
   - ✅ **根因**：布局文件中的尺寸限制 + 窗口尺寸设置时机不当
   - ✅ **修复**：移除布局限制 + 在视图创建后强制应用保存的尺寸

### 🔧 **修复内容**

#### 1. 移除布局文件尺寸限制
```xml
<!-- 修复前 -->
<LinearLayout
    android:minWidth="400dp"
    android:maxWidth="500dp">

<!-- 修复后 -->
<LinearLayout>
```

#### 2. 添加强制尺寸应用
```kotlin
/**
 * 应用窗口尺寸（强制设置保存的尺寸）
 */
private fun applyWindowSize() {
    val window = dialog?.window ?: return
    val attributes = window.attributes ?: return
    
    // 强制应用保存的尺寸
    attributes.width = dpToPx(currentWidth)
    attributes.height = dpToPx(currentHeight)
    window.attributes = attributes
}
```

#### 3. 在视图创建后应用尺寸
```kotlin
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    // ... 其他初始化 ...
    
    // 重新应用保存的窗口尺寸（确保覆盖布局的默认尺寸）
    applyWindowSize()
}
```

### 🔄 **修复后的尺寸应用流程**

1. **初始化** → `loadSavedStates()` → 设置 `currentWidth/currentHeight`
2. **创建Dialog** → `onCreateDialog()` → 初次设置窗口尺寸  
3. **创建视图** → `onViewCreated()` → **强制重新应用保存的尺寸** ✨
4. **大小调整** → `applyResize()` → 实时更新窗口尺寸
5. **保存状态** → `saveCurrentSize()` → 保存到SharedPreferences

### ✅ **修复效果**

- ✅ **首次打开**：显示合理的默认尺寸(400x300dp)
- ✅ **尺寸记忆**：用户调整后的尺寸能正确保存和恢复
- ✅ **立即生效**：从游戏菜单打开时立即显示正确尺寸
- ✅ **无尺寸限制**：支持从最小到全屏的任意尺寸

---

**修复时间**：2024年
**版本状态**：✅ **v1.4 尺寸应用修复完成**

## 尺寸记忆机制修复 (v1.5)

### 🐛 **问题分析**

5. **尺寸记忆机制不一致**
   - ✅ **问题**：大小记忆和位置记忆采用了不同的机制，导致大小记忆不可靠
   - ✅ **根因**：位置记忆在 `onCreateDialog()` 中直接读取，大小记忆却依赖变量传递
   - ✅ **修复**：统一采用位置记忆的机制

### 🔧 **修复方案**

#### 修复前的问题机制：
```kotlin
// 位置记忆（工作正常）
onCreateDialog() {
    val savedX = prefs.getInt(KEY_POSITION_X, 0)  // 直接读取
    attributes.x = savedX
}

// 大小记忆（有问题）
loadSavedStates() {
    currentWidth = prefs.getInt(KEY_KEYBOARD_WIDTH, 400)  // 设置变量
}
onCreateDialog() {
    width = dpToPx(currentWidth)  // 使用变量（可能被覆盖）
}
```

#### 修复后的统一机制：
```kotlin
// 位置记忆和大小记忆都采用相同方式
onCreateDialog() {
    // 位置恢复
    val savedX = prefs.getInt(KEY_POSITION_X, 0)
    val savedY = prefs.getInt(KEY_POSITION_Y, 0)
    
    // 大小恢复（新：直接读取，和位置一致）
    val savedWidth = prefs.getInt(KEY_KEYBOARD_WIDTH, 400)
    val savedHeight = prefs.getInt(KEY_KEYBOARD_HEIGHT, 300)
    currentWidth = savedWidth  // 同步更新变量
    currentHeight = savedHeight
    
    // 应用到窗口属性
    attributes.x = savedX
    attributes.y = savedY
    attributes.width = dpToPx(currentWidth)
    attributes.height = dpToPx(currentHeight)
}
```

### ✅ **修复效果**

- ✅ **机制统一**：大小记忆和位置记忆采用完全相同的机制
- ✅ **读取时机**：都在 `onCreateDialog()` 中直接从 SharedPreferences 读取
- ✅ **保存方式**：都有专门的保存方法 + 综合保存方法
- ✅ **可靠性高**：不依赖变量传递，避免被中间过程覆盖

### 🔄 **修复后的数据流**

#### 大小记忆流程（现在和位置记忆一致）：
1. **打开键盘** → `onCreateDialog()` → 直接从 SharedPreferences 读取大小
2. **创建视图** → `onViewCreated()` → 强制重新应用（双保险）
3. **用户调整** → `applyResize()` → 更新变量并立即应用
4. **调整结束** → `saveCurrentSize()` → 保存到 SharedPreferences
5. **关闭键盘** → `saveCurrentStates()` → 综合保存（包括大小）

---

**修复时间**：2024年
**版本状态**：✅ **v1.5 尺寸记忆机制修复完成**

## 尺寸记忆终极修复 (v1.6)

### 🐛 **问题分析**

6. **尺寸应用时机问题**
   - ✅ **问题**：尺寸设置在 `onCreateDialog` 或 `onViewCreated` 中被布局的 `wrap_content` 覆盖
   - ✅ **根因**：Android窗口和布局的加载时机问题
   - ✅ **修复**：统一在 `onResume` 中应用最终的尺寸和位置

### 🔧 **修复方案**

#### 1. 统一加载状态
```kotlin
private fun loadSavedStates() {
    // ...
    currentWidth = prefs.getInt(KEY_KEYBOARD_WIDTH, 400)
    currentHeight = prefs.getInt(KEY_KEYBOARD_HEIGHT, 300)
}
```

#### 2. 简化 `onCreateDialog`
```kotlin
override fun onCreateDialog(savedInstanceState: Bundle?) {
    // 只加载状态，不应用尺寸
    loadSavedStates()
    // ...
}
```

#### 3. 新增 `onResume`（核心修复）
```kotlin
override fun onResume() {
    super.onResume()

    // 在 onResume 中设置可确保覆盖所有布局的 wrap_content 属性
    dialog?.window?.let { window ->
        val params = window.attributes

        // 恢复尺寸
        params.width = dpToPx(currentWidth)
        params.height = dpToPx(currentHeight)

        // 恢复位置
        val savedX = prefs.getInt(KEY_POSITION_X, -1) // -1检测首次运行
        val savedY = prefs.getInt(KEY_POSITION_Y, -1)
        
        if (savedX == -1 && savedY == -1) {
            params.gravity = android.view.Gravity.CENTER
        } else {
            params.gravity = android.view.Gravity.TOP or android.view.Gravity.START
            params.x = savedX
            params.y = savedY
        }
        
        window.attributes = params
    }
}
```

#### 4. 移除多余方法
- ✅ 移除了 `applyWindowSize()` 方法

### ✅ **修复效果**

- ✅ **时机正确**：`onResume` 是应用窗口尺寸的最可靠时机
- ✅ **逻辑清晰**：加载和应用分离，避免冲突
- ✅ **体验一致**：打开键盘时立即显示正确的记忆尺寸

---

**修复时间**：2024年
**版本状态**：✅ **v1.6 终极修复完成**