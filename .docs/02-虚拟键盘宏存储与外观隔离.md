## 虚拟键盘：宏存储与外观样式隔离设计与修复说明

### 背景
- 历史版本中，按键的宏（HotKeys）与外观样式（如边框、文本、背景色等）均保存在 `element.buttonData` 的同一层级。
- 宏编辑器 `MacroEditor` 最初将 `buttonData` 整体视为“宏的 Map”，即期望 JSON 形如 `{ "0": {type, data}, "1": {...} }`。
- 新版本加入了外观样式的复制/粘贴与批量应用，往 `buttonData` 合并了大量非宏字段（如 `BG_COLOR`、`TEXT_COLOR`、`BORDER_*` 等）。
- 结果：当 `buttonData` 同时包含外观样式与宏时，宏加载（反序列化）出现异常或被覆盖。

### 问题根因
1. 宏编辑器将 `buttonData` 全量解析为 `Map<String, MacroAction>`，遇到外观键或非 `{type, data}` 结构的值时，反序列化失败。
2. 个别表单（如“设置方向键 VK_CODE”）在保存时会构造新的 `JSONObject` 并整体覆盖 `buttonData`，可能误删宏数据（此处影响非 HotKeys 元素，保留说明）。

### 修复方案（已实现）
- 文件：`app/src/main/java/com/limelight/heokami/MacroEditor.kt`
  - 新增宏专属容器键：`MACROS`。
  - 加载（兼容）：优先从 `buttonData.MACROS` 读取；若不存在则从顶层扫描，仅解析值为对象且同时包含 `type` 与 `data` 的项为宏，忽略外观字段。
  - 保存（迁移+合并）：
    - 将内存中的宏列表序列化为 `buttonData.MACROS`；
    - 移除旧版顶层“数字键 -> 宏对象”的遗留项；
    - 保留其它所有非宏字段（外观/行为等），实现“宏与外观完全隔离、互不覆盖”。

### 关键调用点回顾
- 宏执行入口：`VirtualKeyboardConfigurationLoader.createDigitalButton(...)` 在 `ButtonType.HotKeys` 中创建 `MacroEditor(context, element.buttonData, ...)` 并触发 `runMacroAction()`。
- 外观拷贝与粘贴：`VirtualKeyboardConfigurationLoader.applyAppearanceToElement(...)` 只合并 `STYLE_BUTTON_DATA_KEYS` 指定的外观键，保持 `buttonData` 其余键（含 `MACROS`）不变。
- 编辑弹窗保存：`VirtualKeyboardMenu` 在外观保存路径采用“基于原数据合并”的方式写回 `buttonData`，不会清空 `MACROS`。

### 兼容性与迁移
- 兼容旧数据：旧版存放在 `buttonData` 顶层的宏，依然会被加载。
- 首次保存后：将被迁移到 `buttonData.MACROS` 下，避免后续外观操作误伤宏数据。

### 验证建议
1. 创建一个 HotKeys 按钮，配置若干宏动作；
2. 修改该按钮外观（颜色/透明度/描边等），保存；
3. 重新打开宏编辑器，宏应正确显示并可执行；
4. 导出/导入配置，确认 `BUTTON_DATA` 中存在 `MACROS` 且外观键与宏键均保留。

### 影响面
- 宏与外观的存储彻底解耦，避免互相覆盖；
- 旧配置自动迁移，无需用户手动干预；
- 与非 HotKeys 元素的外观/行为逻辑互不影响。

